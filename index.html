<!DOCTYPE html>
<html>
<body>
<h1>Welcome to my Portfolio</h1>
<p>
My name is Max Dagesse, and this webpage hosts my portfolio of work in computer science.
</p>
<h3>Code Review</h3>
<embed src="CodeReview.mp4" autostart="false" height="480" width="640" />
<h3>Artifact: Software Design/Engineering</h3>
<p>
<a href="https://repl.it/@Fenrys/AuthenticationSystemCapstone#Main.java">https://repl.it/@Fenrys/AuthenticationSystemCapstone#Main.java</a>
</p>
<h3>Narrative: Software Design/Engineering</h3>
<p>
	The artifact that I chose for this portion of the portfolio is a login authentication system that I made in Java for my Found In App Development class. The concept for the project was that we had to make one of two software programs for use by a zoo; I chose to make the authentication system, which required users to be able to log in using information stored on a separate credentials file and then see information for their role as an employee of the zoo, which would be pulled from another file. There were three roles initially; the veterinarian, zookeeper, and admin roles. The program accepts username and password input, encodes the password using an MD5 hash, then scans the file containing the credentials line by line looking for a match to the login info. If it finds one, it shows the info associated with the login’s role (also on the credentials file). If not, it tells the user that the login was incorrect, then lets them try again unless three failures in a row are on record. If that’s the case, the program exits.
	I selected this item for use in my portfolio because it demonstrates a number of useful skills that I wanted to place front and center. The first of these is the code language used; I deliberately chose to use three projects in different languages in order to demonstrate my skill in multiple code languages, and this was one of my best projects in Java. It was a fairly advanced program for when I made it, and took very little improvement to become something that I really thought was worth showing off. I also thought that the use of external files as part of the program’s function was something that was worth showing off; in fact, my enhancements to the project are largely centered on this element. These enhancements took the form of two major new additions. One of these was a text-based UI that allowed the user to pick between two major functions of the program. One function was the existing login function; the other was my second major addition, a new branch of the program that allowed the user to create a new login that would be appended to the credentials file. This function called for the user to input the username, password and role for the new account; the program would then encode the password properly, then assemble the information provided by the user into a usable string of login info and append it to the credentials file. Because of where the credentials file was stored, I also had to implement a security check that wouldn’t let the user input the role “credentials”; this would result in the entire credentials file being output by the program on login if it was allowed. If the user tries, they are told that isn’t allowed and made to set a new role.
	I easily met the goals I set in Module One with this particular project; I wanted to add a “new login” feature and make some security improvements, and that’s exactly what I ended up doing. This was a programming language I was more familiar with than any other, as many of my classes here have centered on it, and what I didn’t already know going in, I had no major issues learning quickly. I would class this particular artifact enhancement as a resounding success.
	I had very little trouble with this project enhancement overall. My largest issue was with figuring out how to use the new features I would need to add the file output functions in addition to the file input functions, and even that took me only an hour or so to figure out. This process even ended up adding yet another skill that I’m proud to show off as part of my portfolio; the inverse of the FileInputStream feature I already understood, the FileOutputStream. Overall, I would say that this particular enhancement went very smoothly.
</p>
<h3>Artifact: Databases</h3>

<pre>
#!/usr/bin/python
import json
from bson import json_util
from bson.json_util import dumps
import bottle
from bottle import route, run, request, abort
#imports for database
from pymongo import MongoClient
connection = MongoClient('localhost', 27017)
db = connection['market']
collection = db['stocks']


#Update
@route('/update/<TickerValue>', method='PUT')
def UpdateMyStock(TickerValue):
  jsondata = request.json #Retrieve all data passed in url
  query = { "Ticker" : TickerValue} #Query used to search for documents to update
 
  #Update collection with parameters from command
  for key in jsondata:
    update =  { "$set":{key:jsondata[key]}}
    #updating collection
    collection.update(query,update)
  updateDocs = collection.find({"Ticker":TickerValue}) #Locate documents with appropriate TickerValue
  line = "--" * 50 +"\n" #This will print a line
  result = dumps(updateDocs) #
  return line+"\n   Updated Values:  \n"+str(result)+" \n "+line


#Add
#Without Ticker
@route('/addDocument', method='POST')
def addDocumentStock():
  #get all passed data in a json object using the request.json
  jsonData = request.json
  #insert the document passed to the collection
  newDocument = collection.insert(jsonData) #returns the _id
  retriveDoc = collection.find_one({"_id":newDocument})
  line = "--" * 45 +"\n"
  return line+ "\nAdded: \n "+dumps(retriveDoc)+" \n "+line #return inserted document.

#With Ticker
@route('/addDocument/<tickerValue>', method='POST')
def addDocumentStock(tickerValue):
  #get all passed dat in a json object using the request.json
  jsonData = request.json
  jsonData.update( {'Ticker' : tickerValue} ) 
  #Lets insert the document passed to the collection
  recordId = collection.insert(jsonData) #insert data to the stocks collection
  retriveDoc = collection.find_one({"_id":recordId})
  line = "--" * 50 +"\n"
  return line+ "\nAdded: \n "+dumps(retriveDoc)+" \n "+line #return inserted document.



#Remove
@route('/remove/<TickerValue>', method='GET')
def removeStock(TickerValue):
  query = {"Ticker" :TickerValue} #Searches for matching Ticker values
  result = collection.delete_many(query) #Deletes all documents that match the query
  return "\n Document Removed \n" #return results to the user


#Request Doc
#No Search Term
@route('/search', method='GET')
def requestDocument():
  readDocument = collection.find().limit(1) #Find first document in collection
  #provided
  line = "--" * 50 +"\n"
  return line+" \n "+dumps(readDocument)

#Search By Ticker
@route('/searchTicker/<TickerValue>', method='GET')
def requestDocument(TickerValue):
  readDocument = collection.find({"Ticker":TickerValue}) #Find all documents with appropriate TickerValue
  #provided
  line = "--" * 50 +"\n"
  return line+"\nSearch Criteria [Ticker Value]: \n "+dumps(readDocument)

#Search By Sector
@route('/searchSector/<SectorValue>', method='GET')
def requestDocument(SectorValue):
  readDocument = collection.find({"Sector":SectorValue}) #Find all documents with appropriate SectorValue
  #provided
  line = "--" * 50 +"\n"
  return line+"\nSearch Criteria [Sector]: \n "+dumps(readDocument)

#Search By Industry
@route('/searchIndustry/<IndustryValue>', method='GET')
def requestDocument(IndustryValue):
  readDocument = collection.find({"Industry":IndustryValue}) #Find all documents with appropriate IndustryValue
  #provided
  line = "--" * 50 +"\n"
  return line+"\nSearch Criteria [Industry]: \n "+dumps(readDocument)


#Stock Summary
@route('/stockSummary', method='POST')
def getReport(): 
  line = "--" * 50 +"\n"
  tickerSymbols = request.json.get('list') #retrieves the value of the list key in the url data
  #Removing the curl Braces from the List 
  tickerSymbols = tickerSymbols.replace("[","")
  tickerSymbols = tickerSymbols.replace("]","")
  tickerSymbols = list(tickerSymbols.split(","))
  EmptyTickers = list()
  print(tickerSymbols)
  underline = "_" * 30;
  #This for loop uses each ticker in the list,
  #gets the summary and adds it to the items list
  for ticker in tickerSymbols:
      item = Pipeline(ticker)
      print(item)
      #Building string for display
      EmptyTickers.append(line+" \t\t\t Report for Ticker ["+ticker+"]  \n \t\t\t"+underline+" \n"+item+"\n\n "+line)
  return EmptyTickers  #return a list of items


#Get Industry Report
#Most URLs replace spaces with +, so for any industry with spaces in the name, we replace spaces with + signs
@route('/getIndustryReport/<industryName>', method='GET')
def getReport(industryName):
  industry = industryName.replace("+"," ") 
  #Stage 1
  print("\n\n\n "+industry+"\n\n")
  result2 = IndustryPipeline(industry)
  firstStage = { '$project': {'Industry':1, 'Ticker':1,'Float Short':1,'Relative Volume':1,'Volume':1,'Performance (Year)':1 } }
  #Stage 2
  secondStage = { '$match': { "Industry": industry } }
  print("\n\n\n "+str(secondStage)+"\n\n")
  #Stage 3
  thirdStage = { '$group': { '_id': "$Industry", 'Total Float Short': {'$sum': "$Float Short" },
                           'Average Relative Volume':{'$avg':"$Relative Volume"},
                           'Average Volume':{'$avg':'$Volume'},
                           'Maximum Performance (Year)':{'$max':'$Performance (Year)'},
			   'Minimum Performance (Year)':{'$min':'$Performance (Year)'},
			   'Maximum Volume':{'$max':'$Volume'},
			   'Minimum Volume':{'$min':'$Volume'},
                           'Total Volume':{'$sum':'$Volume'} } }
  #Stage 4, adding limit
  fourthStage = { '$limit' : 5 }
  query = [firstStage,secondStage,thirdStage,fourthStage]
  print(str(query))
  result=collection.aggregate(query)
  result = dumps(result)
  #print results to user
  return "-------- \n \t\t\t Portfolio Report For "+industry+" Industries \n\n "+result+" \n-------- \n"+result2+"\n"

#Get Sector Report
#Most URLs replace spaces with +, so for any sector with spaces in the name, we replace spaces with + signs
@route('/getSectorReport/<sectorName>', method='GET')
def getReport(sectorName):
  sector = sectorName.replace("+"," ") 
  #Stage 1
  print("\n\n\n "+sector+"\n\n")
  result2 = SectorPipeline(sector)
  firstStage = { '$project': {'Sector':1, 'Ticker':1,'Float Short':1,'Relative Volume':1,'Volume':1,'Performance (Year)':1 } }
  #Stage 2
  secondStage = { '$match': { "Sector": sector } }
  print("\n\n\n "+str(secondStage)+"\n\n")
  #Stage 3
  thirdStage = { '$group': { '_id': "$Sector", 'Total Float Short': {'$sum': "$Float Short" },
                           'Average Relative Volume':{'$avg':"$Relative Volume"},
                           'Average Volume':{'$avg':'$Volume'},
                           'Maximum Performance (Year)':{'$max':'$Performance (Year)'},
			   'Minimum Performance (Year)':{'$min':'$Performance (Year)'},
			   'Maximum Volume':{'$max':'$Volume'},
			   'Minimum Volume':{'$min':'$Volume'},
                           'Total Volume':{'$sum':'$Volume'} } }
  #Stage 4, adding limit
  fourthStage = { '$limit' : 5 }
  query = [firstStage,secondStage,thirdStage,fourthStage]
  print(str(query))
  result=collection.aggregate(query)
  result = dumps(result)
  #print results to user
  return "-------- \n \t\t\t Portfolio Report For "+sector+" Sector \n\n "+result+" \n-------- \n"+result2+"\n"

#Pipeline

def Pipeline(ticker):
  firstStage = { '$project': { 'Ticker':1,'Float Short':1,'Relative Volume':1,'Volume':1,'Performance (Year)':1,'Profit Margin':1 } }
  secondStage = { '$match': { "Ticker": ticker } }
  thirdStage = { '$group': { '_id': "$Ticker", 'Total Float Short': {'$sum': "$Float Short" },
                           'Average Relative Volume':{'$avg':"$Relative Volume"},
			   'Average Volume':{'$avg':'$Volume'},
			   'Maximum Volume':{'$max':'$Volume'},
			   'Minimum Volume':{'$min':'$Volume'},
                           'Total Volume':{'$sum':'$Volume'},
			   'Minimum Performance (Year)':{'$min':'$Performance (Year)'},
                           'Maximum Performance (Year)':{'$max':'$Performance (Year)'},
                           'Minimum Volume Used':{'$min':'$Volume'},
			   'Maximum Volume Used':{'$max':'$Volume'},
			   'Average Profit Margin':{'$avg':'$Profit Margin'} } }
  myQuery = [firstStage,secondStage,thirdStage]
  result=collection.aggregate(myQuery) 
  result = dumps(result)
  return result



def IndustryPipeline(industry):
  firstStage = { '$project': { 'Industry':1,'Float Short':1,'Price':1,'Average True Range':1,'50-Day Simple Moving Average':1,'Change':1,'Profit Margin':1 } }
  secondStage = { '$match': { "Industry": industry } }
  thirdStage = { '$group': { '_id': "$Industry", 'Total Float Short': {'$sum': "$Float Short" },
                           'Average Average True Range':{'$avg':"$Average True Range"},
                           'Total Price':{'$sum':'$Price'},
                           'Average Price':{'$avg':'$Price'},
			   'Minimum Price':{'$min':'$Price'},
			   'Maximum Price':{'$max':'$Price'},
			   'Average 50-Day Simple Moving Average (Year)':{'$avg':'$50-Day Simple Moving Average'},
			   'Minimum 50-Day Simple Moving Average (Year)':{'$min':'$50-Day Simple Moving Average'},
                           'Maximum 50-Day Simple Moving Average (Year)':{'$max':'$50-Day Simple Moving Average'},
			   'Average Change':{'$avg':'$Change'},
                           'Minimum Change':{'$min':'$Change'},
			   'Maximum Change':{'$max':'$Change'},
			   'Average Profit Margin':{'$avg':'$Profit Margin'} } }
  fourthStage = { '$limit' : 5 }
  myQuery = [firstStage,secondStage,thirdStage,fourthStage]
  result=collection.aggregate(myQuery) 
  result = dumps(result)
  return "-------- \n More Information: \n"+result+"\n"

def SectorPipeline(sector):
  firstStage = { '$project': { 'Sector':1,'Float Short':1,'Price':1,'Average True Range':1,'50-Day Simple Moving Average':1,'Change':1,'Profit Margin':1 } }
  secondStage = { '$match': { "Sector": sector } }
  thirdStage = { '$group': { '_id': "$Sector", 'Total Float Short': {'$sum': "$Float Short" },
                           'Average Average True Range':{'$avg':"$Average True Range"},
                           'Total Price':{'$sum':'$Price'},
                           'Average Price':{'$avg':'$Price'},
			   'Minimum Price':{'$min':'$Price'},
			   'Maximum Price':{'$max':'$Price'},
			   'Average 50-Day Simple Moving Average (Year)':{'$avg':'$50-Day Simple Moving Average'},
			   'Minimum 50-Day Simple Moving Average (Year)':{'$min':'$50-Day Simple Moving Average'},
                           'Maximum 50-Day Simple Moving Average (Year)':{'$max':'$50-Day Simple Moving Average'},
			   'Average Change':{'$avg':'$Change'},
                           'Minimum Change':{'$min':'$Change'},
			   'Maximum Change':{'$max':'$Change'},
			   'Average Profit Margin':{'$avg':'$Profit Margin'} } }
  fourthStage = { '$limit' : 5 }
  myQuery = [firstStage,secondStage,thirdStage,fourthStage]
  result=collection.aggregate(myQuery) 
  result = dumps(result)
  return "-------- \n More Information: \n"+result+"\n"

#Main program
  
if __name__ == '__main__':
  run(debug=True,reloader = True)
  #run(host='localhost', port=8080)
</pre>

<h3>Narrative: Databases</h3>
<p>
	The project that I chose as the artifact for this section of the portfolio is a RESTful API that I made for my Client/Server Development class. The API was made in Python and is intended for use in MongoDB. Specifically, the API was made with a stocks database in mind. The original project had six main functions. The first four are the basic CRUD operations; creating, reading, updating and deleting documents. The create command took data from the URL used to curl the command and used it to make a new document in the database; the read, update, and delete commands would respectively print, update, or delete all documents with a given ticker symbol. The other two commands were more specialized; one displayed stock summaries by ticker symbol, and the other reported on the top five stocks in an industry of the user’s choice. These two commands were reliant on MongoDB’s pipeline functions.
	I selected this item to fill an artifact role in my portfolio because it demonstrates several skills that I want to place prominently for potential employers to see. First off, this project continues a theme with my other selections; the language once again changes in order to demonstrate my skills with multiple coding languages. In all, my portfolio now demonstrates my skills in the use of Python, C++, and Java; these are three of the most common coding languages across multiple industries, and being proficient in all three is an excellent skill to showcase. This specific project also demonstrates my ability to work with MongoDB in a way that could be of use to companies that work with it; being able to create and maintain an API that may be easier for other employees to use than MongoDB’s own interface is a useful skill. 
	My enhancements to the project are largely centered on demonstrating this latter skill in particular. The first major enhancement I made was to add supplementary read commands that allow for the use of search terms other than the ticker symbols. Specifically, I added commands that used the industry and sector values in addition to the two existing commands (which either searched based on ticker symbol or just printed the first document in the database. These additional search commands increase the program’s flexibility in terms of finding and grouping documents, making it a more genuinely useful tool for stocks research when used with the appropriate databases. The second major enhancement was the addition of more statistics to the pipeline functions; they now bring up significantly more information relevant to the stocks info than they were before, making them far more informative. I also added a third pipeline connected to a sector report feature; this functions similarly to the industry report pipeline, but groups documents by sector instead of by industry.
	 I would say that I met my goals from Module One handily with this project; my main goals were to make the program more useful in a professional setting, and I found a few different routes to that goal and took all of them. The main effect of this was providing the user with a lot more control over how documents are grouped and found when using the various functions of the program, which makes the program much more effective as a management tool. The API is decently fleshed out now, and I believe that it could conceivably see use in a professional setting. I would consider this set of enhancements to be successful.
	I didn’t have much trouble with this set of enhancements; this class was one of my most recent, so the work I had already done was still very fresh in my mind. Enhancing it further was pretty easy to handle with everything already recent in my memory. Overall, I would say that I’m very satisfied with the end results of my enhancements.
</p>
<h3>Artifact: Algorithms & Data Structures</h3>
<p>
<a href="https://repl.it/@Fenrys/HashTableCapstone#main.cpp">https://repl.it/@Fenrys/HashTableCapstone#main.cpp</a>
</p>
<h3>Narrative: Algorithms & Data Structures</h3>
<p>
	The project I selected for this artifact was a hash table searcher that I made in C++ as part of my Data Structures and Algorithms class. It was designed to pull bids from an external table and sort them using a tree structure, which could then be searched later using IDs assigned to each bid using a hash table. Each of the program’s functions also had a simple timer attached to it, which tracks the amount of time the search takes to find the correct result. The search terms were hardcoded in this initial version of the program; you could find and delete one bid, and pull data from one file out of the two included. The program was the culmination of several weeks of work in which we learned about and implemented each of the major components of this project one by one, and it ended up being a fairly involved program that demonstrated a number of useful skills that I would use in many of the classes that followed it.
	It is for precisely that reason that I selected this program as part of my portfolio; the skills I learned in this class would prove to be foundational and are all things that I wanted to place in a position of importance, as well as continuing to build further on other skills that I’d learned already. Much like my last artifact, this program is capable of accepting data from an external file, which is a useful skill to show off. This project also demonstrated my skills with data structures and algorithms quite effectively. Even more so than the last project, it also demonstrates modularity; portions of this project can very easily be excised and used in other similar projects with full functionality maintained. This is definitely something I want to show off. Finally, as I mentioned in my last narrative, I deliberately chose projects in multiple coding languages to show off my talents with multiple languages; this project is the one for C++. My enhancements for this particular artifact went in several major directions. The first planned route was to tweak my algorithm and attempt to improve on it; however, I made little headway going in this direction. Thankfully, this was actually for a good reason; it seems that I had underestimated my initial work on this project going in, and the algorithm was already remarkably efficient. While I believe I made a few successful tweaks, they shaved microseconds off at most. The greater amount of legwork in enhancements came from two functionality improvements that I made. The first of these was the addition of an input for the search and delete functions that overrode the hardcoded search term; this allowed the user to find a bid of their choice and genuinely make use of the program’s functions. The second was a switch on the loading function that allowed the user to pick between the two files included to load, or input their own if they had a properly formatted file. These two features put together make the program a genuinely useful tool that demonstrates my proficiency with data structures and algorithms quite effectively.
	I didn’t quite meet the goals I set in Module One with this enhancement, but I’m not overly bothered by that for the reasons stated above about my failure to significantly improve my algorithm. As far as I can tell, my results with this artifact indicate that my algorithm didn’t actually need heavy improvement; I’m still quite happy with the end result and the enhancements I made in functionality. The program now serves as an effective and useful demonstration of my skills, which is more than I could have ever asked for. I did make some headway on algorithm improvement, even; it’s just not nearly as much as I thought I would, but not for a bad reason.
	As noted above, I did have some trouble with this enhancement due to my lack of ability to significantly improve my algorithm. I did a lot of research looking into why that turned out to be the case, and ended up learning a fair bit more than I already did about what makes an algorithm efficient in the first place, and why mine was already so remarkably effective. Having come away from the issue with a lot more knowledge than I started, I’m not particularly upset about my “failure”. Rather, I’m glad that I will be able to make use of this knowledge and algorithm in the future, and even more happy than I already was to showcase it in my portfolio. Overall, I’m quite happy with how this artifact turned out.
</p>
<h3>Reflection</h3>
</body>
</html>